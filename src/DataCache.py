"""
used to cache data that is read from the api.  CKAN objects can have relationships
to other objects. For example a group or organization relates to different users,
or a package can be owned by an organization

This class is developed on an as needed basis to help store and retrieve these
relationships

"""
import constants
import logging
import CKANTransform
import CKAN

LOGGER = logging.getLogger(__name__)

# pylint: disable=logging-format-interpolation

class DataCacheFactory:
    """
    used to maintain a lookup data struct so that autogenerated unique ids
    can be quickly translated between source and destination.

    for example the field owner_org refers to a auto generated unique id for
    the organization... so owner_org is a value that related to id in an
    organization object

    This class maintains the following data structure to allow the remapping
    of autogen ids to take place.

    <autogen field>: This is the auto generated field name on the source side
                     that a lookup is being maintained for.  Fields that this
                     class maintains lookups for are described in the
                     transformation config file in the section: field_mapping

                     Because there can be more than one field mapping maintained
                     per object type, the field_name is the first key in the
                     data struct.

    <data type>    : data type  or object type is the type of data that the
                     mapping is defined for.  Typical data types in ckan include
                     users, groups, organizations, packages and resources.

    <data origin>  : Identifies if the data comes from the source CKAN instance
                     or the destination ckan instance.  Valid values for
                     this parameter are identified in the enumeration:
                     constants.DATA_SOURCE

    <autogen field value>: This is a value that exists in the column described in
                     the parameter above <autogen field>

    <value>         : all of the above identify a hierarchical data structure that
                     ultimately resolves to this value, which contains the user
                     generated unique id for the record that can be identified
                     by the value in the parameter <autogen field value>

    a specific example where the transformation config file contains the
    following fieldmapping values:

    ....
      "field_mapping": [
            {
                "user_populated_field": "name",
                "auto_populated_field": "id"
            }
    ...

    self.cacheStruct['id']['organizations']['src']['2dfjksdfjwlji8hfzkioeihfsl'] = 'BCGOV_organization'

    'id' is the autogenerated field name
    'organizations' is the object that contains the field 'id'
    'src' means we are describing values from the source CKAN instance
    '2dfjksdfjwlji8hfzkioeihfsl' is an example of a value that is found in the column 'id'
    'BCGOV_organization' is the user generated unique id that corresponds with the
        autogenerated unique id '2dfjksdfjwlji8hfzkioeihfsl'

    destination objects generally follow the same pattern bug destination objects
    flip the last entry and the value, example:

    self.cacheStruct['id']['organizations']['dest']['BCGOV_organization'] = 'klsdjjfonvuweoiisdfxoi3o89kjsk'

    The struct can now easily translate the autogen id for the org BCGOV_organization
    from 2dfjksdfjwlji8hfzkioeihfsl on the source side to klsdjjfonvuweoiisdfxoi3o89kjsk
    on the destination side.

    :raises inValidDataType: [description]
    :return: [description]
    :rtype: [type]
    """
    def __init__(self):
        self.transConf = CKANTransform.TransformationConfig()
        self.cacheLoader = CacheLoader()

        # example struct for source:
        #    struct['id']['organization']['src']['2dfjksdfjwlji8hfzkioeihfsl'] = 'BCGOV_organization'

        # example struct for dest:
        #    self.cacheStruct['id']['organizations']['dest']['BCGOV_organization'] = 'klsdjjfonvuweoiisdfxoi3o89kjsk'
        self.cacheStruct = {}

    def initCacheStruct(self, autoGenFieldName):
        """inits the data struct for a mapping field.  Sets up the struct
         to allow for easier population of the struct

        :param autoGenFieldName: [description]
        :type autoGenFieldName: [type]
        """
        if autoGenFieldName not in self.cacheStruct:
            self.cacheStruct[autoGenFieldName] = {}
        for dataType in self.VALID_TRANSFORM_TYPES:
            self.cacheStruct[autoGenFieldName][dataType] = {}
            for dataOrigin in self.DATA_SOURCE:
                # translated to with example
                # <field_name>, id
                #     <datatype>, organizations
                #         <data origin>, src
                self.cacheStruct[autoGenFieldName][dataType][dataOrigin.name] = {}

    def addData(self, dataSet, dataOrigin):
        """reads the data in the source dataset populating the cache for
        that data type, allowing for rapid translation of autogen fields between
        instances.

        :param srcDataSet: an input CKANDataSet object for a source ckan instance
        :type srcDataSet: CKANData.CKANDataSet
        :param dataOrigin: is the data from src || dest
        :type dataOrigin: str
        """
        if not isinstance(dataOrigin, constants.DATA_SOURCE):
            msg = (
                "An invalid dataOrigin type was provided.  The type provided "
                + f"is {type(dataOrigin)}.  This is not "
                + "a valid type for this parameter, must be a constants.DATA_SOURCE type"
            )
            raise inValidDataType(msg)
        dataType = dataSet.dataType
        fieldmaps = self.transConf.getFieldMappings(dataType)

        for fieldmap in fieldmaps:
            autoGenFieldName = fieldmap[constants.FIELD_MAPPING_AUTOGEN_FIELD]
            userGenFieldName = fieldmap[constants.FIELD_MAPPING_USER_FIELD]

            self.initCacheStruct(autoGenFieldName)

            dataSet.reset()
            LOGGER.info("Caching auto vs user unique ids")

            for ckanRecord in dataSet:
                autoGenFieldValue = ckanRecord.getFieldValue(autoGenFieldName)
                userGenFieldValue = ckanRecord.getFieldValue(userGenFieldName)

                if dataOrigin == constants.DATA_SOURCE.SRC:
                    self.cacheStruct[autoGenFieldName][dataType][dataOrigin.name][
                        autoGenFieldValue
                    ] = userGenFieldValue
                elif dataOrigin == constants.DATA_SOURCE.DEST:
                    self.cacheStruct[autoGenFieldName][dataType][dataOrigin.name][
                        userGenFieldValue
                    ] = autoGenFieldValue

    def addRawData(self, rawData, dataType, dataOrigin):
        """[summary]

        :param rawData: a list of objects with properties
        :type rawData: list of dict
        :param dataType: a CKAN object type or data type, users, orgs, groups ...
        :type dataType: str
        :param dataOrigin: the data orgin enumeration
        :type dataOrigin: constants.DATA_SOURCE
        """

        fieldmaps = self.transConf.getFieldMappings(dataType)

        for record in rawData:
            for fieldmap in fieldmaps:
                autoGenFieldName = fieldmap[constants.FIELD_MAPPING_AUTOGEN_FIELD]
                userGenFieldName = fieldmap[constants.FIELD_MAPPING_USER_FIELD]

                autoGenFieldValue = record[autoGenFieldName]
                userGenFieldValue = record[userGenFieldName]

                self.initCacheStruct(autoGenFieldName)
                # cacheStruct[autoGenFieldName][dataType][dataOrigin.name] = {}
                self.cacheStruct[autoGenFieldName][dataType][dataOrigin.name][autoGenFieldValue] = userGenFieldValue

    def isDatatypeLoaded(self, objType, autoFieldName):
        """returns boolean to identify the specified data type has been loaded

        :param objType: the object type as defined in constants.VALID_TRANSFORM_TYPES
        :type objType: str
        :param autoFieldName: The name of the field in 'objType' that should be
             loaded / cached
        :type autoFieldName: str
        """
        retVal =  False
        if autoFieldName in self.cacheStruct:
            if objType in self.cacheStruct[autoFieldName]:
                retVal = True
        return retVal

    def loadData(self, objType, autoFieldName):
        """When a record is requested, this method will get called to see if the
        data for the datatype has already been loaded, if not then it will make
        the appropriate calls to the api to load it.

        :param dataType: [description]
        :type dataType: [type]
        """
        if not self.isDatatypeLoaded(objType, autoFieldName):
            self.cacheLoader.loadType(self, objType)

    def src2DestRemap(self, autoFieldName, objType, autoValue):
        """receives an organizations property name and the autogenerated
        value for that property, returns the equivalent autogenerated property
        that refers to the same object on the destination side

        :param autoFieldName: The field name that the 'autoValue' corresponds
            with.
        :type autoFieldName: str
        :param objType: The object type that the autoFieldName is a part of.
        :type objType: str
        :param autoValue: The actual value on of the field on the source side
            that needs to be translated.
        :type autoValue: str
        """
        self.loadData(objType, autoFieldName)
        srcUserValue = self.cacheStruct[autoFieldName][objType][constants.DATA_SOURCE.SRC][autoValue]
        destAutoValue = self.cacheStruct[autoFieldName][objType][constants.DATA_SOURCE.DEST][srcUserValue]
        return destAutoValue

class CacheLoader:
    """This class glues the CKAN api to the cache, if sections of the cache have
    Not been populated then these methods will get called to populate various
    sections of the cache.  This should take place on an as needed basis.
    """
    def __init__(self):
        ckanParams = CKAN.CKANParams()
        destCKANWrap = ckanParams.getDestWrapper()
        srcCKANWrap = ckanParams.getSrcWrapper()

        self.wrapperMap = {
            constants.DATA_SOURCE.SRC: srcCKANWrap,
            constants.DATA_SOURCE.DEST: destCKANWrap
        }

        self.loadMethodMap = {
            constants.TRANSFORM_TYPE_ORGS: self.loadOrgs,
            constants.TRANSFORM_TYPE_USERS: self.loadUsers,
            constants.TRANSFORM_TYPE_GROUPS: self.loadGroups,
            constants.TRANSFORM_TYPE_PACKAGES: self.loadPackages,
            constants.TRANSFORM_TYPE_RESOURCES: self.loadResources
        }

    def loadType(self, dataCacheObj, dataType):
        """load the data for the specific data type

        :param cacheReference: [description]
        :type cacheReference: [type]
        :param dataType: [description]
        :type dataType: [type]
        """
        for dataOriginEnum in constants.DATA_SOURCE:
            rawData = self.loadMethodMap[dataType](dataOriginEnum)
            dataCacheObj.addRawData(rawData, dataType, dataOriginEnum)

    def loadOrgs(self, dataOrigin):
        return self.wrapperMap[dataOrigin].getOrganizations(includeData=True)

    def loadUsers(self, dataOrigin):
        return self.wrapperMap[dataOrigin].getUsers(includeData=True)

    def loadGroups(self, dataOrigin):
        return self.wrapperMap[dataOrigin].getGroups(includeData=True)

    def loadPackages(self, dataOrigin):
        return self.wrapperMap[dataOrigin].getPackagesAndData(includeData=True)

    def loadResources(self, dataOrigin):
        return self.wrapperMap[dataOrigin].getResources(includeData=True)

class inValidDataType(ValueError):
    """Raised when the DataCacheFactory configuration encounters an unexpected
    value or type
    """

    def __init__(self, message):
        LOGGER.error(f"error message: {message}")
        self.message = message
