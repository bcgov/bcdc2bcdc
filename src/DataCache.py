"""
used to cache data that is read from the api.  CKAN objects can have relationships
to other objects. For example a group or organization relates to different users,
or a package can be owned by an organization

This class is developed on an as needed basis to help store and retrieve these
relationships

"""
import constants
import logging
import CKANTransform

LOGGER = logging.getLogger(__name__)


class DataCacheFactory:
    def __init__(self):

        self.transConf = CKANTransform.TransformationConfig()
        self.fieldmap = self.transConf.getFieldMappings()

        # cache struct will be:
        #    * datatype: (user, org, group, etc...):
        #    * origin:  (src || dest)
        #    * auto value
        #   == user value
        self.cacheStruct = {}
        self.initCacheStruct()

    def initCacheStruct(self):
        for dataType in self.VALID_TRANSFORM_TYPES:
            self.cacheStruct[dataType] = {}
            for dataOrigin in self.VALID_DATA_ORIGINS:
                self.cacheStruct[dataType][dataOrigin] = {}
                #self.cacheStruct[dataType] = {"src": {}, "dest": {}}

    def addData(self, dataSet, dataOrigin):
        """reads the data in the source dataset populating the cache for
        that data type, allowing for rapid translation of autogen fields between
        instances.

        :param srcDataSet: an input CKANDataSet object for a source ckan instance
        :type srcDataSet: CKANData.CKANDataSet
        :param dataOrigin: is the data from src || dest
        :type dataOrigin: str
        """
        if dataOrigin not in constants.VALID_DATA_ORIGINS:
            msg = f'specified a dataOrigin value of {dataOrigin}.  This is not ' + \
                  f'a valid type, possible values include {constants.VALID_DATA_ORIGINS}'
            raise inValidDataType(msg)

        dataSet.reset()
        dataType = dataSet.dataType

        for ckanRecord in dataSet:
            autoGenFieldName = self.fieldmap[constants.FIELD_MAPPING_AUTOGEN_FIELD]
            userGenFieldName = self.fieldmap[constants.FIELD_MAPPING_USER_FIELD]

            autoGenFieldValue = ckanRecord.getFieldValue(autoGenFieldName)
            userGenFieldValue = ckanRecord.getFieldValue(userGenFieldName)

            self.cacheStruct[dataType][dataOrigin][autoGenFieldValue] = userGenFieldValue



class OrganizationCache:
    def __init__(self):
        self.cacheMap = {"src": {}, "dest": {}}

    def addSrcAutoGenFieldMap(self, mapType, autoValue, userValue):
        # [src][id][234jslvmlkwlrek] = databc
        self.cacheMap['src'][mapType][autoValue] = userValue

    def addDestAutoGenFieldMap(self, mapType, autoValue, userValue):
        self.cacheMap['dest'][mapType][autoValue] = userValue

    def hasSrcType(self, mapType, mapTypeValue):
        return self.hasType('src', mapType, mapTypeValue)

    def hasDestType(self, mapType, mapTypeValue):
        """[summary]

        :param mapType: [description]
        :type mapType: [type]
        :param mapTypeValue: [description]
        :type mapTypeValue: [type]
        :return: [description]
        :rtype: [type]
        """
        return self.hasType('dest', mapType, mapTypeValue)

    def hasType(self, inputType, mapType, mapTypeValue):
        """
        A generic method that allows you to determine of a mapping exists.

        :param inputType: the mapping type, possible values (src, dest)
        :type inputType: str
        :param mapType: the property that the mapping applies to for organizations,
            example 'id'
        :type mapType: str
        :param mapTypeValue: The autogenerated value for the 'mapType' key
        :type mapTypeValue: str
        :return: boolean indicating if this mapping type exists
        :rtype: bool
        """
        if (mapType in self.cacheMap[inputType]) and \
            mapTypeValue in self.cacheMap[inputType][mapType]:
            retVal = True
        return retVal

    def getDestAutoGenValue(self, mapType, userValue):
        retVal = None
        for autoGenValue in self.cacheMap['dest'][mapType]:
            if self.cacheMap['dest'][mapType][autoGenValue] == userValue:
                retVal = autoGenValue
                break
        return retVal

    def src2DestRemap(self, mapType, autoValue):
        """receives an organizations property name and the autogenerated
        value for that property, returns the equivalent autogenerated property
        that refers to the same object on the destination side

        :param mapType: When searching for source side property / value combination
            this property contains the property name
        :type mapType: str
        :param autoValue: The property value on the source side
        :type autoValue: str
        :return: the mapType on value for the destination side
        :rtype: str
        """
        retVal = None
        if self.hasSrcType(mapType, autoValue) and \
                self.hasDestType(mapType, autoValue):
            # the source user defined unique identifier corresponding
            # value for the autoValue
            srcUsergenUniqueID = self.cacheMap['src'][mapType][autoValue]
            retVal = self.getDestAutoGenValue(mapType, srcUsergenUniqueID)
        return retVal

class inValidDataType(ValueError):
    """Raised when the DataCacheFactory configuration encounters an unexpected
    value or type
    """

    def __init__(self, message):
        LOGGER.error(f"error message: {message}")
        self.message = message
