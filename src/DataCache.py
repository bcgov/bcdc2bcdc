"""
used to cache data that is read from the api.  CKAN objects can have relationships
to other objects. For example a group or organization relates to different users,
or a package can be owned by an organization

This class is developed on an as needed basis to help store and retrieve these
relationships

"""
import constants
import logging
import CKANTransform

LOGGER = logging.getLogger(__name__)


class DataCacheFactory:
    def __init__(self):

        self.transConf = CKANTransform.TransformationConfig()
        self.fieldmap = self.transConf.getFieldMappings()

        # cache struct will be:
        #    * datatype: (user, org, group, etc...):
        #    * origin:  (src || dest)
        #    * auto value
        #   == user value
        self.cacheStruct = {}
        self.initCacheStruct()

    def initCacheStruct(self):
        for dataType in self.VALID_TRANSFORM_TYPES:
            self.cacheStruct[dataType] = {}
            for dataOrigin in self.DATA_SOURCE:
                self.cacheStruct[dataType][dataOrigin.name] = {}

    def addData(self, dataSet, dataOrigin):
        """reads the data in the source dataset populating the cache for
        that data type, allowing for rapid translation of autogen fields between
        instances.

        :param srcDataSet: an input CKANDataSet object for a source ckan instance
        :type srcDataSet: CKANData.CKANDataSet
        :param dataOrigin: is the data from src || dest
        :type dataOrigin: str
        """
        if not isinstance(dataOrigin, constants.DATA_SOURCE):
            msg = (
                "An invalid dataOrigin type was provided.  The type provided "
                + f"is {type(dataOrigin)}.  This is not "
                + "a valid type for this parameter, must be a constants.DATA_SOURCE type"
            )
            raise inValidDataType(msg)

        dataSet.reset()
        dataType = dataSet.dataType
        LOGGER.info("Caching auto vs user unique ids")

        for ckanRecord in dataSet:
            autoGenFieldName = self.fieldmap[constants.FIELD_MAPPING_AUTOGEN_FIELD]
            userGenFieldName = self.fieldmap[constants.FIELD_MAPPING_USER_FIELD]

            autoGenFieldValue = ckanRecord.getFieldValue(autoGenFieldName)
            userGenFieldValue = ckanRecord.getFieldValue(userGenFieldName)

            self.cacheStruct[dataType][dataOrigin.name][
                autoGenFieldValue
            ] = userGenFieldValue

    def isDatatypeLoaded(self):
        """returns boolean to identify the specified data type has been loaded,
        """
        pass

    def loadData(self, dataType):
        """When a record is requested, this method will get called to see if the
        data for the datatype has already been loaded, if not then it will make
        the appropriate calls to the api to load it.

        :param dataType: [description]
        :type dataType: [type]
        """
        pass

    def src2DestRemap(self, mapType, autoValue):
        """receives an organizations property name and the autogenerated
        value for that property, returns the equivalent autogenerated property
        that refers to the same object on the destination side

        :param mapType: When searching for source side property / value combination
            this property contains the property name
        :type mapType: str
        :param autoValue: The property value on the source side
        :type autoValue: str
        :return: the mapType on value for the destination side
        :rtype: str
        """
        # retVal = None
        # if self.hasSrcType(mapType, autoValue) and self.hasDestType(mapType, autoValue):
        #     # the source user defined unique identifier corresponding
        #     # value for the autoValue
        #     srcUsergenUniqueID = self.cacheMap["src"][mapType][autoValue]
        #     retVal = self.getDestAutoGenValue(mapType, srcUsergenUniqueID)
        # return retVal


class CacheLoader:
    """This class glues the CKAN api to the cache, if sections of the cache have
    Not been populated then these methods will get called to populate various
    sections of the cache.  This should take place on an as needed basis.
    """
    def __init__(self, dataType):


class OrganizationCache:
    def __init__(self):
        self.cacheMap = {"src": {}, "dest": {}}

    def addSrcAutoGenFieldMap(self, mapType, autoValue, userValue):
        # [src][id][234jslvmlkwlrek] = databc
        self.cacheMap["src"][mapType][autoValue] = userValue

    def addDestAutoGenFieldMap(self, mapType, autoValue, userValue):
        self.cacheMap["dest"][mapType][autoValue] = userValue

    def hasSrcType(self, mapType, mapTypeValue):
        return self.hasType("src", mapType, mapTypeValue)

    def hasDestType(self, mapType, mapTypeValue):
        """[summary]

        :param mapType: [description]
        :type mapType: [type]
        :param mapTypeValue: [description]
        :type mapTypeValue: [type]
        :return: [description]
        :rtype: [type]
        """
        return self.hasType("dest", mapType, mapTypeValue)

    def hasType(self, inputType, mapType, mapTypeValue):
        """
        A generic method that allows you to determine of a mapping exists.

        :param inputType: the mapping type, possible values (src, dest)
        :type inputType: str
        :param mapType: the property that the mapping applies to for organizations,
            example 'id'
        :type mapType: str
        :param mapTypeValue: The autogenerated value for the 'mapType' key
        :type mapTypeValue: str
        :return: boolean indicating if this mapping type exists
        :rtype: bool
        """
        if (mapType in self.cacheMap[inputType]) and mapTypeValue in self.cacheMap[
            inputType
        ][mapType]:
            retVal = True
        return retVal

    def getDestAutoGenValue(self, mapType, userValue):
        retVal = None
        for autoGenValue in self.cacheMap["dest"][mapType]:
            if self.cacheMap["dest"][mapType][autoGenValue] == userValue:
                retVal = autoGenValue
                break
        return retVal

    def src2DestRemap(self, mapType, autoValue):
        """receives an organizations property name and the autogenerated
        value for that property, returns the equivalent autogenerated property
        that refers to the same object on the destination side

        :param mapType: When searching for source side property / value combination
            this property contains the property name
        :type mapType: str
        :param autoValue: The property value on the source side
        :type autoValue: str
        :return: the mapType on value for the destination side
        :rtype: str
        """
        retVal = None
        if self.hasSrcType(mapType, autoValue) and self.hasDestType(mapType, autoValue):
            # the source user defined unique identifier corresponding
            # value for the autoValue
            srcUsergenUniqueID = self.cacheMap["src"][mapType][autoValue]
            retVal = self.getDestAutoGenValue(mapType, srcUsergenUniqueID)
        return retVal


class inValidDataType(ValueError):
    """Raised when the DataCacheFactory configuration encounters an unexpected
    value or type
    """

    def __init__(self, message):
        LOGGER.error(f"error message: {message}")
        self.message = message
